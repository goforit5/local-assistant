name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  pre-deploy-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Verify branch
      run: |
        if [[ "${{ github.ref }}" != "refs/heads/main" ]]; then
          echo "Error: Deployments must be from the main branch"
          exit 1
        fi

    - name: Check CI status
      uses: actions/github-script@v8
      with:
        script: |
          const { data: checks } = await github.rest.checks.listForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha
          });

          const failedChecks = checks.check_runs.filter(
            check => check.conclusion !== 'success' && check.name !== 'Pre-deployment Checks'
          );

          if (failedChecks.length > 0) {
            core.setFailed('CI checks have not passed. Cannot deploy.');
          }

  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: pre-deploy-checks
    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: spdx-json
        output-file: sbom.spdx.json

    - name: Upload SBOM
      uses: actions/upload-artifact@v6
      with:
        name: sbom
        path: sbom.spdx.json

  database-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: ${{ inputs.environment }}
    if: ${{ !inputs.skip_migrations }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: "3.11"

    - name: Install dependencies
      run: |
        pip install alembic asyncpg psycopg2-binary

    - name: Run migrations
      env:
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
      run: |
        alembic upgrade head

    - name: Verify migration
      env:
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
      run: |
        alembic current

  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: [build-and-push, database-migrations]
    if: always() && (needs.database-migrations.result == 'success' || needs.database-migrations.result == 'skipped')
    environment:
      name: ${{ inputs.environment }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Deploy to server
      id: deploy
      env:
        DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
        DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        DEPLOY_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
      run: |
        # This is a placeholder for actual deployment steps
        # Configure based on your deployment method:
        # - Docker Compose remote deployment
        # - Kubernetes apply
        # - Cloud provider CLI (AWS ECS, GCP Cloud Run, Azure Container Apps)
        echo "Deploying image: $IMAGE_TAG"
        echo "url=https://assistant.${{ inputs.environment }}.example.com" >> $GITHUB_OUTPUT

    - name: Update Docker Compose services
      env:
        DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
      run: |
        echo "Would deploy via docker-compose pull && docker-compose up -d"
        # ssh $DEPLOY_USER@$DEPLOY_HOST "cd /app && docker-compose pull && docker-compose up -d"

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy
    environment: ${{ inputs.environment }}

    steps:
    - name: Wait for services to stabilize
      run: sleep 30

    - name: Check API health
      env:
        API_URL: ${{ secrets.API_URL || 'https://api.local-assistant.com' }}
      run: |
        max_attempts=10
        attempt=0

        while [ $attempt -lt $max_attempts ]; do
          response=$(curl -s -o /dev/null -w "%{http_code}" $API_URL/health || echo "000")

          if [ "$response" = "200" ]; then
            echo "Health check passed (HTTP $response)"
            exit 0
          fi

          attempt=$((attempt + 1))
          echo "Health check failed (HTTP $response), attempt $attempt/$max_attempts"
          sleep 10
        done

        echo "Health check failed after $max_attempts attempts"
        exit 1

    - name: Check database connectivity
      env:
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
      run: |
        echo "Database connectivity check placeholder"
        # psql $DATABASE_URL -c "SELECT 1;"

    - name: Check Redis connectivity
      env:
        REDIS_URL: ${{ secrets.REDIS_URL }}
      run: |
        echo "Redis connectivity check placeholder"
        # redis-cli -u $REDIS_URL ping

    - name: Smoke tests
      env:
        API_URL: ${{ secrets.API_URL || 'https://api.local-assistant.com' }}
        API_KEY: ${{ secrets.API_KEY }}
      run: |
        # Basic smoke tests
        curl -f $API_URL/health
        curl -f $API_URL/metrics
        echo "Smoke tests passed"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: failure()
    environment: ${{ inputs.environment }}

    steps:
    - name: Rollback deployment
      env:
        DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      run: |
        echo "Rolling back to previous version"
        # ssh $DEPLOY_USER@$DEPLOY_HOST "cd /app && docker-compose down && git checkout HEAD~1 && docker-compose up -d"

    - name: Notify rollback
      uses: actions/github-script@v8
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: 'üö® Deployment to ${{ inputs.environment }} failed and was rolled back.'
          })

  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [health-check]
    if: always()

    steps:
    - name: Deployment success notification
      if: needs.health-check.result == 'success'
      run: |
        echo "‚úÖ Deployment to ${{ inputs.environment }} completed successfully"
        # Add Slack/Discord/email notification here

    - name: Deployment failure notification
      if: needs.health-check.result == 'failure'
      run: |
        echo "‚ùå Deployment to ${{ inputs.environment }} failed"
        # Add Slack/Discord/email notification here
